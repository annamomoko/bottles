<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abstract Fish Swimming</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
            cursor: none;
        }
        
        .instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }
        
        .status {
            position: absolute;
            top: 60px;
            left: 20px;
            color: #ffd700;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }
        
        .camera-status {
            position: absolute;
            top: 100px;
            left: 20px;
            color: #87ceeb;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }
        
        .debug-info {
            position: absolute;
            top: 130px;
            left: 20px;
            color: #90ee90;
            font-size: 12px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="instructions">Press 'K' to scatter the fish! Or show your hand to the camera!</div>
    <div class="status" id="status">Fish swimming in formation</div>
    <div class="camera-status" id="camera-status">Camera: Initializing...</div>
    <div class="debug-info" id="debug-info">Hand detection: Inactive</div>
    <video id="video" style="position: absolute; top: 10px; right: 10px; width: 160px; height: 120px; border: 2px solid white; border-radius: 8px; z-index: 20;"></video>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        const cameraStatus = document.getElementById('camera-status');
        const debugInfo = document.getElementById('debug-info');
        const video = document.getElementById('video');
        
        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Fish class (back to original simple design)
        class Fish {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 20 + 15;
                this.baseSpeed = Math.random() * 1.5 + 0.8;
                this.speed = this.baseSpeed;
                this.angle = Math.random() * Math.PI * 2;
                this.targetAngle = 0;
                this.scatterAngle = 0;
                this.color = this.generateColor();
                this.tail = [];
                this.maxTailLength = 8;
                this.swimOffset = Math.random() * Math.PI * 2;
                this.personalSpace = this.size * 3;
                this.isScattering = false;
                this.scatterSpeed = 0;
            }
            
            generateColor() {
                const colors = [
                    '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', 
                    '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update(isScattered, groupAngle, allFish) {
                // Store previous position for tail
                this.tail.unshift({x: this.x, y: this.y});
                if (this.tail.length > this.maxTailLength) {
                    this.tail.pop();
                }
                
                if (isScattered) {
                    this.targetAngle = this.scatterAngle;
                    this.speed = this.scatterSpeed;
                    this.isScattering = true;
                } else {
                    if (this.isScattering) {
                        this.speed = this.baseSpeed;
                        this.isScattering = false;
                    }
                    
                    // Natural schooling behavior
                    let avgX = 0, avgY = 0, neighbors = 0;
                    let separationX = 0, separationY = 0;
                    let avgAngle = 0;
                    
                    // Check nearby fish for flocking behavior
                    allFish.forEach(other => {
                        if (other === this) return;
                        
                        const dx = other.x - this.x;
                        const dy = other.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < this.personalSpace * 4) {
                            neighbors++;
                            avgX += other.x;
                            avgY += other.y;
                            avgAngle += other.angle;
                            
                            if (distance < this.personalSpace) {
                                separationX -= dx / distance;
                                separationY -= dy / distance;
                            }
                        }
                    });
                    
                    if (neighbors > 0) {
                        avgX /= neighbors;
                        avgY /= neighbors;
                        const cohesionAngle = Math.atan2(avgY - this.y, avgX - this.x);
                        avgAngle /= neighbors;
                        
                        let separationAngle = Math.atan2(separationY, separationX);
                        
                        this.targetAngle = 
                            groupAngle * 0.4 + 
                            cohesionAngle * 0.2 + 
                            avgAngle * 0.3 + 
                            separationAngle * 0.1 +
                            Math.sin(Date.now() * 0.002 + this.swimOffset) * 0.2;
                    } else {
                        this.targetAngle = groupAngle + Math.sin(Date.now() * 0.002 + this.swimOffset) * 0.3;
                    }
                }
                
                // Smooth angle transition
                let angleDiff = this.targetAngle - this.angle;
                if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                this.angle += angleDiff * (isScattered ? 0.15 : 0.08);
                
                // Move fish with natural swimming motion
                const swimWave = Math.sin(Date.now() * 0.01 + this.swimOffset) * 0.2;
                this.x += Math.cos(this.angle + swimWave) * this.speed;
                this.y += Math.sin(this.angle + swimWave) * this.speed;
                
                // Wrap around screen
                if (this.x < -50) this.x = canvas.width + 50;
                if (this.x > canvas.width + 50) this.x = -50;
                if (this.y < -50) this.y = canvas.height + 50;
                if (this.y > canvas.height + 50) this.y = -50;
            }
            
            draw() {
                ctx.save();
                
                // Draw tail
                for (let i = 0; i < this.tail.length; i++) {
                    const alpha = (this.tail.length - i) / this.tail.length * 0.3;
                    const size = this.size * (0.3 + alpha);
                    
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.tail[i].x, this.tail[i].y, size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.globalAlpha = 1;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Draw fish body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw fish outline
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw eye
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(this.size * 0.3, -this.size * 0.1, this.size * 0.15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(this.size * 0.35, -this.size * 0.1, this.size * 0.08, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw fins
                ctx.fillStyle = this.color;
                ctx.globalAlpha = 0.7;
                
                // Top fin
                ctx.beginPath();
                ctx.moveTo(-this.size * 0.2, -this.size * 0.4);
                ctx.lineTo(this.size * 0.2, -this.size * 0.8);
                ctx.lineTo(this.size * 0.6, -this.size * 0.3);
                ctx.closePath();
                ctx.fill();
                
                // Bottom fin
                ctx.beginPath();
                ctx.moveTo(-this.size * 0.2, this.size * 0.4);
                ctx.lineTo(this.size * 0.2, this.size * 0.8);
                ctx.lineTo(this.size * 0.6, this.size * 0.3);
                ctx.closePath();
                ctx.fill();
                
                // Tail fin
                ctx.beginPath();
                ctx.moveTo(-this.size * 0.8, -this.size * 0.4);
                ctx.lineTo(-this.size * 1.2, 0);
                ctx.lineTo(-this.size * 0.8, this.size * 0.4);
                ctx.lineTo(-this.size * 0.6, 0);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
            
            scatter() {
                this.scatterAngle = Math.random() * Math.PI * 2;
                this.scatterSpeed = this.baseSpeed * (2 + Math.random() * 2);
            }
        }
        
        // Water splash effects
        class WaterSplash {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.particles = [];
                this.life = 1.0;
                
                // Create splash particles
                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 12,
                        vy: (Math.random() - 0.5) * 12,
                        life: 1.0,
                        size: Math.random() * 8 + 3
                    });
                }
            }
            
            update() {
                this.life -= 0.03;
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.95;
                    p.vy *= 0.95;
                    p.life -= 0.02;
                    p.size *= 0.98;
                });
                
                this.particles = this.particles.filter(p => p.life > 0);
                return this.life > 0;
            }
            
            draw() {
                this.particles.forEach(p => {
                    ctx.save();
                    ctx.globalAlpha = p.life * 0.6;
                    ctx.fillStyle = '#87ceeb';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.globalAlpha = p.life * 0.3;
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }
        }
        
        // Ripple effect
        class WaterRipple {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 0;
                this.maxRadius = 150;
                this.life = 1.0;
            }
            
            update() {
                this.radius += 4;
                this.life = 1 - (this.radius / this.maxRadius);
                return this.life > 0;
            }
            
            draw() {
                ctx.save();
                ctx.globalAlpha = this.life * 0.3;
                ctx.strokeStyle = '#87ceeb';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.globalAlpha = this.life * 0.1;
                ctx.lineWidth = 6;
                ctx.stroke();
                ctx.restore();
            }
        }
        
        // Create fish school
        const fish = [];
        const fishCount = 25;
        const waterEffects = [];
        
        // Create fish in a more spread out formation
        for (let i = 0; i < fishCount; i++) {
            const angle = (i / fishCount) * Math.PI * 2;
            const radius = 100 + Math.random() * 200;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            fish.push(new Fish(
                centerX + Math.cos(angle) * radius + (Math.random() - 0.5) * 100,
                centerY + Math.sin(angle) * radius + (Math.random() - 0.5) * 100
            ));
        }
        
        // Game state
        let isScattered = false;
        let scatterTime = 0;
        let groupAngle = 0;
        let lastHandDetection = 0;
        let handDetectionCooldown = 3000; // 3 second cooldown
        
        // Hand detection variables
        let handDetectionEnabled = false;
        let baselineSet = false;
        let baselineSkinPixels = 0;
        let frameCount = 0;
        
        // Initialize camera and improved hand detection
        async function initializeCamera() {
            try {
                cameraStatus.textContent = 'Camera: Requesting permission...';
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 320, height: 240, facingMode: 'user' }
                });
                
                video.srcObject = stream;
                video.play();
                
                cameraStatus.textContent = 'Camera: Setting up hand detection...';
                
                // Wait for video to be ready, then start hand detection
                video.addEventListener('loadeddata', () => {
                    setTimeout(() => {
                        startHandDetection();
                        cameraStatus.textContent = 'Camera: Active - Show hand to scatter fish!';
                    }, 1000);
                });
                
            } catch (error) {
                console.error('Camera access failed:', error);
                cameraStatus.textContent = 'Camera: Access denied - Use keyboard only';
                debugInfo.textContent = 'Hand detection: Disabled (no camera)';
            }
        }
        
        function startHandDetection() {
            const detectionCanvas = document.createElement('canvas');
            const detectionCtx = detectionCanvas.getContext('2d');
            detectionCanvas.width = 160;
            detectionCanvas.height = 120;
            
            handDetectionEnabled = true;
            
            function detectHand() {
                if (!handDetectionEnabled || video.readyState !== video.HAVE_ENOUGH_DATA) {
                    requestAnimationFrame(detectHand);
                    return;
                }
                
                frameCount++;
                detectionCtx.drawImage(video, 0, 0, detectionCanvas.width, detectionCanvas.height);
                
                // Get image data for analysis
                const imageData = detectionCtx.getImageData(0, 0, detectionCanvas.width, detectionCanvas.height);
                const data = imageData.data;
                
                // Analyze multiple regions for hand detection
                const regions = [
                    { x: 40, y: 30, w: 80, h: 60 },  // center
                    { x: 20, y: 20, w: 60, h: 50 },  // top-left
                    { x: 80, y: 20, w: 60, h: 50 },  // top-right
                    { x: 40, y: 50, w: 80, h: 50 }   // bottom-center
                ];
                
                let totalSkinPixels = 0;
                let handLikeRegions = 0;
                
                regions.forEach(region => {
                    let skinPixels = 0;
                    let totalPixels = 0;
                    let skinClusters = 0;
                    
                    for (let y = region.y; y < region.y + region.h && y < detectionCanvas.height; y++) {
                        for (let x = region.x; x < region.x + region.w && x < detectionCanvas.width; x++) {
                            const i = (y * detectionCanvas.width + x) * 4;
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            
                            if (isImprovedSkinTone(r, g, b)) {
                                skinPixels++;
                            }
                            totalPixels++;
                        }
                    }
                    
                    const skinRatio = skinPixels / totalPixels;
                    totalSkinPixels += skinPixels;
                    
                    // A region is "hand-like" if it has a good concentration of skin pixels
                    if (skinRatio > 0.25 && skinPixels > 200) {
                        handLikeRegions++;
                    }
                });
                
                // Set baseline after first 30 frames
                if (!baselineSet && frameCount > 30) {
                    baselineSkinPixels = totalSkinPixels;
                    baselineSet = true;
                    debugInfo.textContent = `Hand detection: Ready (baseline: ${Math.round(baselineSkinPixels)})`;
                }
                
                // Hand detection logic: significant increase from baseline + hand-like regions
                const skinIncrease = totalSkinPixels - baselineSkinPixels;
                const handDetected = baselineSet && 
                                  skinIncrease > 500 && 
                                  handLikeRegions >= 1 && 
                                  totalSkinPixels > 800;
                
                // Update debug info
                debugInfo.textContent = `Skin pixels: ${Math.round(totalSkinPixels)} (Δ${Math.round(skinIncrease)}) | Hand-like regions: ${handLikeRegions}`;
                
                if (handDetected && Date.now() - lastHandDetection > handDetectionCooldown) {
                    triggerScatter();
                    lastHandDetection = Date.now();
                    cameraStatus.textContent = 'Camera: Hand detected! ✋';
                    debugInfo.textContent = 'HAND DETECTED! Fish scattered!';
                    
                    setTimeout(() => {
                        if (handDetectionEnabled) {
                            cameraStatus.textContent = 'Camera: Active - Show hand to scatter fish!';
                        }
                    }, 2000);
                }
                
                requestAnimationFrame(detectHand);
            }
            
            detectHand();
        }
        
        function isImprovedSkinTone(r, g, b) {
            // More robust skin tone detection
            // Multiple skin tone ranges to account for different ethnicities
            
            // Condition 1: Traditional RGB skin detection
            const cond1 = (r > 95 && g > 40 && b > 20 && 
                          Math.max(r, g, b) - Math.min(r, g, b) > 15 &&
                          Math.abs(r - g) > 15 && r > g && r > b);
            
            // Condition 2: YCrCb color space approximation
            const y = 0.299 * r + 0.587 * g + 0.114 * b;
            const cr = 0.713 * (r - y);
            const cb = 0.564 * (b - y);
            const cond2 = (cr >= -25 && cr <= 25 && cb >= -15 && cb <= 15);
            
            // Condition 3: HSV-based detection
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const diff = max - min;
            let h = 0;
            
            if (diff !== 0) {
                if (max === r) h = ((g - b) / diff) % 6;
                else if (max === g) h = (b - r) / diff + 2;
                else h = (r - g) / diff + 4;
                h = Math.round(h * 60);
                if (h < 0) h += 360;
            }
            
            const s = max === 0 ? 0 : diff / max;
            const v = max / 255;
            
            const cond3 = ((h >= 0 && h <= 50) || (h >= 300 && h <= 360)) && 
                         s >= 0.23 && s <= 0.68 && v >= 0.35;
            
            return cond1 || (cond2 && cond3);
        }
        
        function triggerScatter() {
            if (!isScattered) {
                isScattered = true;
                scatterTime = Date.now();
                status.textContent = 'Fish scattered! Regrouping in 3 seconds...';
                
                // Scatter all fish and create water effects
                fish.forEach(f => {
                    f.scatter();
                    
                    // Create splash effects around each fish
                    waterEffects.push(new WaterSplash(f.x, f.y));
                    waterEffects.push(new WaterRipple(f.x, f.y));
                });
                
                // Create some random splashes for dramatic effect
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        waterEffects.push(new WaterSplash(
                            Math.random() * canvas.width,
                            Math.random() * canvas.height
                        ));
                        waterEffects.push(new WaterRipple(
                            Math.random() * canvas.width,
                            Math.random() * canvas.height
                        ));
                    }, Math.random() * 500);
                }
            }
        }
        
        // Animation loop
        function animate() {
            // Clear canvas with fade effect
            ctx.fillStyle = 'rgba(30, 60, 114, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update group angle for natural movement
            groupAngle += 0.005;
            
            // Check if scatter time is over
            if (isScattered && Date.now() - scatterTime > 3000) {
                isScattered = false;
                status.textContent = 'Fish regrouping...';
                setTimeout(() => {
                    if (!isScattered) {
                        status.textContent = 'Fish swimming in formation';
                    }
                }, 1000);
            }
            
            // Update and draw fish
            fish.forEach((f, index) => {
                f.update(isScattered, groupAngle, fish);
                f.draw();
            });
            
            // Update and draw water effects
            for (let i = waterEffects.length - 1; i >= 0; i--) {
                if (!waterEffects[i].update()) {
                    waterEffects.splice(i, 1);
                } else {
                    waterEffects[i].draw();
                }
            }
            
            // Add some bubbles for atmosphere
            if (Math.random() < 0.1) {
                drawBubble();
            }
            
            requestAnimationFrame(animate);
        }
        
        function drawBubble() {
            const x = Math.random() * canvas.width;
            const y = canvas.height;
            const size = Math.random() * 10 + 5;
            
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#87ceeb';
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'k') {
                triggerScatter();
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // Start animation and camera
        animate();
        initializeCamera();
    </script>
</body>
</html>